# ThreadCoroutineTree
线程，线程状态转换，协程技术研究


![](https://i.imgur.com/idMgUmn.png)

<pre>
线程状态：

        1）新建状态：线程对象被创建后，就进入了创建状态。
        2）就绪状态：thread.start()，随时可能被CPU调度执行。
        3）运行状态：线程获取CPU权限进行执行。
        5）阻塞状态：
                   1）等待阻塞：
                      wait()方法，让线程等待某个工作的完成。
                   2）同步阻塞：
                      线程在获取synchronized同步锁失败，它会进入同步阻塞状态。
                   3）其他阻塞：
                      通过调用线程sleep, join或者发出IO请求，当sleep状态超时，join等待
                      线程终止或者超时，或者IO处理完毕，线程进入就绪状态。
       6）死亡状态：线程执行完了或者因异常退出了run方法，该线程结束生命周期。
</pre>

<pre>
wait(): 线程调用wait()之后，会释放它锁持有的“同步锁”

        负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这
        里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法
        之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还
        持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获
        取到“对象的同步锁”进而继续运行。

        总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且
        仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因
</pre>

<pre>
yield(): 作用是让步，能让当前线程由“运行状态”进入到“就绪状态”，从而让其他具有相同优先级的
         线程获取CPU执行权，但是并不能保证当前线程调用yield之后，其他具有相同优先级的线程
         就一定能够获得执行权，也可能进入等待队列继续等待。

         yield()方法不会释放锁。
</pre>

<pre>
sleep: 让当前线程休眠，即当前线程会从“运行状态”进入“阻塞休眠状态”，sleep()会指定时间，线程
       休眠的时间会大于等于该休眠时间，在线程重新被唤醒后，它会由“阻塞状态”编程”就绪状态“，
       从而等待CPU调度。

       sleep不会释放锁。
</pre>